/*
 * Legalesign API
 *
 * Legalesign.com is an electronic signature software. This is the documentation for its REST API.   Start by creating a trial account at https://app1.legalesign.com/auth/intro/. Upon account activation, select the API dev option.  Get an API key by emailing support@legalesign with background on your use-case and skills. You will need to show experience in API dev.  You will be in sandbox mode that will limit you to 5 signers. Add them on https://app1.legalesign.com/acc/settings/#api. Contact support to move to production mode when you are ready.  For any queries contact us at support@legalesign.com. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@legalesign.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Org.OpenAPITools.Client.OpenAPIDateConverter;

namespace Org.OpenAPITools.Model
{
    /// <summary>
    /// Send a document to be signed. In addition to the required fields, the POST must also  contain either text (raw html) or a reference to a saved template (html) or a  templatepdf (uploaded pdf). Also recommended - do_email, auto_archive and pdftext (if using pdf).
    /// </summary>
    [DataContract]
    public partial class DocumentPost :  IEquatable<DocumentPost>, IValidatableObject
    {
        /// <summary>
        /// 1 to store password, 2 for to delete from our records upon final signing.
        /// </summary>
        /// <value>1 to store password, 2 for to delete from our records upon final signing.</value>
        public enum PdfPasswordTypeEnum
        {
            /// <summary>
            /// Enum passtype1 for value: 1
            /// </summary>
            passtype1 = 1,

            /// <summary>
            /// Enum passtype2 for value: 2
            /// </summary>
            passtype2 = 2

        }

        /// <summary>
        /// 1 to store password, 2 for to delete from our records upon final signing.
        /// </summary>
        /// <value>1 to store password, 2 for to delete from our records upon final signing.</value>
        [DataMember(Name="pdf_password_type", EmitDefaultValue=false)]
        public PdfPasswordTypeEnum? PdfPasswordType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="DocumentPost" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected DocumentPost() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DocumentPost" /> class.
        /// </summary>
        /// <param name="group">group (required).</param>
        /// <param name="name">name (required).</param>
        /// <param name="text">Raw html. This API call must contain either one of the attributes text, templatepdf, template..</param>
        /// <param name="templatepdf">Resource URI of templatepdf object. This API call must contain either one of the attributes text, templatepdf, template..</param>
        /// <param name="template">Resource URI of text template object. This call must contain either one of the attributes text, templatepdf, template..</param>
        /// <param name="signers">signers (required).</param>
        /// <param name="signatureType">Use 4 to get your executed PDF Certified. Recommended. Defaults to 1 (uses a sha256 hash for document integrity). (default to 1).</param>
        /// <param name="appendPdf">Append Legalesign validation info to final PDF. If not included uses the group default. (default to false).</param>
        /// <param name="autoArchive">Send to archive soon after signing. Keeps web app clutter free (default to true).</param>
        /// <param name="doEmail">Use Legalesign email to send notification emails. If false suppresses all emails. (default to false).</param>
        /// <param name="ccEmails">Comma delimited string of email addresses that are notified of signing or rejection..</param>
        /// <param name="convertSenderToSigner">If any sender fields are left blank, convert them to signer fields..</param>
        /// <param name="footer">Text doc only. The footer for the final pdf. Use keyword \\\&quot;default\\\&quot; to use group default footer..</param>
        /// <param name="footerHeight">Text based doc only. Pixel height of PDF footer, if used. 1px &#x3D; 0.025cm.</param>
        /// <param name="header">Text based doc only. The header for the final pdf. Use keyword \\\&quot;default\\\&quot; to use group header footer..</param>
        /// <param name="headerHeight">Text based doc only. Pixel height of final PDF footer, if used. 1px &#x3D; 0.025cm.</param>
        /// <param name="pdfPassword">Set a password. Must be ascii encode-able, you must also set signature_type to 4 and choose a pdf_password_type..</param>
        /// <param name="pdfPasswordType">1 to store password, 2 for to delete from our records upon final signing..</param>
        /// <param name="pdftext">Assign values to PDF sender fields, use field labels as keys. Requires unique fields labels. See also strict_fields..</param>
        /// <param name="redirect">URL to send the signer to after signing (instead of download page).  Your URL will include query parameters with ID and state information as follows: YOUR-URL?signer&#x3D;[signer_uid]&amp;doc&#x3D;[doc_id]&amp;group&#x3D;[group_id]&amp;signer_state&#x3D;[signer_status]&amp;doc_state&#x3D;[doc_status].</param>
        /// <param name="reminders">Put &#39;default&#39; if you wish to use the default reminder schedule in the group (go to web app to set default schedule).</param>
        /// <param name="returnSignerLinks">Return document links for signers in the response BODY..</param>
        /// <param name="signersInOrder">Notify signers in their order sequence. If false all are notified simulataneously..</param>
        /// <param name="signertext">Add custom placeholders to signer fields, using labels as keys in an object (as for pdftext). Relies on unique labelling..</param>
        /// <param name="strictFields">pdftext fails silently for invalid field value, set to true to return an error.</param>
        /// <param name="tag">tag.</param>
        /// <param name="user">Assign document another user in the group. Defaults to API.</param>
        public DocumentPost(string group = default(string), string name = default(string), string text = default(string), string templatepdf = default(string), string template = default(string), List<DocumentSignerPost> signers = default(List<DocumentSignerPost>), int signatureType = 1, bool appendPdf = false, bool autoArchive = true, bool doEmail = false, string ccEmails = default(string), bool convertSenderToSigner = default(bool), string footer = default(string), long footerHeight = default(long), string header = default(string), long headerHeight = default(long), string pdfPassword = default(string), PdfPasswordTypeEnum? pdfPasswordType = default(PdfPasswordTypeEnum?), Dictionary<string, string> pdftext = default(Dictionary<string, string>), string redirect = default(string), string reminders = default(string), bool returnSignerLinks = default(bool), bool signersInOrder = default(bool), Dictionary<string, string> signertext = default(Dictionary<string, string>), bool strictFields = default(bool), string tag = default(string), string user = default(string))
        {
            // to ensure "group" is required (not null)
            if (group == null)
            {
                throw new InvalidDataException("group is a required property for DocumentPost and cannot be null");
            }
            else
            {
                this.Group = group;
            }

            // to ensure "name" is required (not null)
            if (name == null)
            {
                throw new InvalidDataException("name is a required property for DocumentPost and cannot be null");
            }
            else
            {
                this.Name = name;
            }

            // to ensure "signers" is required (not null)
            if (signers == null)
            {
                throw new InvalidDataException("signers is a required property for DocumentPost and cannot be null");
            }
            else
            {
                this.Signers = signers;
            }

            this.Text = text;
            this.Templatepdf = templatepdf;
            this.Template = template;
            // use default value if no "signatureType" provided
            if (signatureType == null)
            {
                this.SignatureType = 1;
            }
            else
            {
                this.SignatureType = signatureType;
            }
            // use default value if no "appendPdf" provided
            if (appendPdf == null)
            {
                this.AppendPdf = false;
            }
            else
            {
                this.AppendPdf = appendPdf;
            }
            // use default value if no "autoArchive" provided
            if (autoArchive == null)
            {
                this.AutoArchive = true;
            }
            else
            {
                this.AutoArchive = autoArchive;
            }
            // use default value if no "doEmail" provided
            if (doEmail == null)
            {
                this.DoEmail = false;
            }
            else
            {
                this.DoEmail = doEmail;
            }
            this.CcEmails = ccEmails;
            this.ConvertSenderToSigner = convertSenderToSigner;
            this.Footer = footer;
            this.FooterHeight = footerHeight;
            this.Header = header;
            this.HeaderHeight = headerHeight;
            this.PdfPassword = pdfPassword;
            this.PdfPasswordType = pdfPasswordType;
            this.Pdftext = pdftext;
            this.Redirect = redirect;
            this.Reminders = reminders;
            this.ReturnSignerLinks = returnSignerLinks;
            this.SignersInOrder = signersInOrder;
            this.Signertext = signertext;
            this.StrictFields = strictFields;
            this.Tag = tag;
            this.User = user;
        }

        /// <summary>
        /// Gets or Sets Group
        /// </summary>
        [DataMember(Name="group", EmitDefaultValue=true)]
        public string Group { get; set; }

        /// <summary>
        /// Gets or Sets Name
        /// </summary>
        [DataMember(Name="name", EmitDefaultValue=true)]
        public string Name { get; set; }

        /// <summary>
        /// Raw html. This API call must contain either one of the attributes text, templatepdf, template.
        /// </summary>
        /// <value>Raw html. This API call must contain either one of the attributes text, templatepdf, template.</value>
        [DataMember(Name="text", EmitDefaultValue=false)]
        public string Text { get; set; }

        /// <summary>
        /// Resource URI of templatepdf object. This API call must contain either one of the attributes text, templatepdf, template.
        /// </summary>
        /// <value>Resource URI of templatepdf object. This API call must contain either one of the attributes text, templatepdf, template.</value>
        [DataMember(Name="templatepdf", EmitDefaultValue=false)]
        public string Templatepdf { get; set; }

        /// <summary>
        /// Resource URI of text template object. This call must contain either one of the attributes text, templatepdf, template.
        /// </summary>
        /// <value>Resource URI of text template object. This call must contain either one of the attributes text, templatepdf, template.</value>
        [DataMember(Name="template", EmitDefaultValue=false)]
        public string Template { get; set; }

        /// <summary>
        /// Gets or Sets Signers
        /// </summary>
        [DataMember(Name="signers", EmitDefaultValue=true)]
        public List<DocumentSignerPost> Signers { get; set; }

        /// <summary>
        /// Use 4 to get your executed PDF Certified. Recommended. Defaults to 1 (uses a sha256 hash for document integrity).
        /// </summary>
        /// <value>Use 4 to get your executed PDF Certified. Recommended. Defaults to 1 (uses a sha256 hash for document integrity).</value>
        [DataMember(Name="signature_type", EmitDefaultValue=false)]
        public int SignatureType { get; set; }

        /// <summary>
        /// Append Legalesign validation info to final PDF. If not included uses the group default.
        /// </summary>
        /// <value>Append Legalesign validation info to final PDF. If not included uses the group default.</value>
        [DataMember(Name="append_pdf", EmitDefaultValue=false)]
        public bool AppendPdf { get; set; }

        /// <summary>
        /// Send to archive soon after signing. Keeps web app clutter free
        /// </summary>
        /// <value>Send to archive soon after signing. Keeps web app clutter free</value>
        [DataMember(Name="auto_archive", EmitDefaultValue=false)]
        public bool AutoArchive { get; set; }

        /// <summary>
        /// Use Legalesign email to send notification emails. If false suppresses all emails.
        /// </summary>
        /// <value>Use Legalesign email to send notification emails. If false suppresses all emails.</value>
        [DataMember(Name="do_email", EmitDefaultValue=false)]
        public bool DoEmail { get; set; }

        /// <summary>
        /// Comma delimited string of email addresses that are notified of signing or rejection.
        /// </summary>
        /// <value>Comma delimited string of email addresses that are notified of signing or rejection.</value>
        [DataMember(Name="cc_emails", EmitDefaultValue=false)]
        public string CcEmails { get; set; }

        /// <summary>
        /// If any sender fields are left blank, convert them to signer fields.
        /// </summary>
        /// <value>If any sender fields are left blank, convert them to signer fields.</value>
        [DataMember(Name="convert_sender_to_signer", EmitDefaultValue=false)]
        public bool ConvertSenderToSigner { get; set; }

        /// <summary>
        /// Text doc only. The footer for the final pdf. Use keyword \\\&quot;default\\\&quot; to use group default footer.
        /// </summary>
        /// <value>Text doc only. The footer for the final pdf. Use keyword \\\&quot;default\\\&quot; to use group default footer.</value>
        [DataMember(Name="footer", EmitDefaultValue=false)]
        public string Footer { get; set; }

        /// <summary>
        /// Text based doc only. Pixel height of PDF footer, if used. 1px &#x3D; 0.025cm
        /// </summary>
        /// <value>Text based doc only. Pixel height of PDF footer, if used. 1px &#x3D; 0.025cm</value>
        [DataMember(Name="footer_height", EmitDefaultValue=false)]
        public long FooterHeight { get; set; }

        /// <summary>
        /// Text based doc only. The header for the final pdf. Use keyword \\\&quot;default\\\&quot; to use group header footer.
        /// </summary>
        /// <value>Text based doc only. The header for the final pdf. Use keyword \\\&quot;default\\\&quot; to use group header footer.</value>
        [DataMember(Name="header", EmitDefaultValue=false)]
        public string Header { get; set; }

        /// <summary>
        /// Text based doc only. Pixel height of final PDF footer, if used. 1px &#x3D; 0.025cm
        /// </summary>
        /// <value>Text based doc only. Pixel height of final PDF footer, if used. 1px &#x3D; 0.025cm</value>
        [DataMember(Name="header_height", EmitDefaultValue=false)]
        public long HeaderHeight { get; set; }

        /// <summary>
        /// Set a password. Must be ascii encode-able, you must also set signature_type to 4 and choose a pdf_password_type.
        /// </summary>
        /// <value>Set a password. Must be ascii encode-able, you must also set signature_type to 4 and choose a pdf_password_type.</value>
        [DataMember(Name="pdf_password", EmitDefaultValue=false)]
        public string PdfPassword { get; set; }


        /// <summary>
        /// Assign values to PDF sender fields, use field labels as keys. Requires unique fields labels. See also strict_fields.
        /// </summary>
        /// <value>Assign values to PDF sender fields, use field labels as keys. Requires unique fields labels. See also strict_fields.</value>
        [DataMember(Name="pdftext", EmitDefaultValue=false)]
        public Dictionary<string, string> Pdftext { get; set; }

        /// <summary>
        /// URL to send the signer to after signing (instead of download page).  Your URL will include query parameters with ID and state information as follows: YOUR-URL?signer&#x3D;[signer_uid]&amp;doc&#x3D;[doc_id]&amp;group&#x3D;[group_id]&amp;signer_state&#x3D;[signer_status]&amp;doc_state&#x3D;[doc_status]
        /// </summary>
        /// <value>URL to send the signer to after signing (instead of download page).  Your URL will include query parameters with ID and state information as follows: YOUR-URL?signer&#x3D;[signer_uid]&amp;doc&#x3D;[doc_id]&amp;group&#x3D;[group_id]&amp;signer_state&#x3D;[signer_status]&amp;doc_state&#x3D;[doc_status]</value>
        [DataMember(Name="redirect", EmitDefaultValue=false)]
        public string Redirect { get; set; }

        /// <summary>
        /// Put &#39;default&#39; if you wish to use the default reminder schedule in the group (go to web app to set default schedule)
        /// </summary>
        /// <value>Put &#39;default&#39; if you wish to use the default reminder schedule in the group (go to web app to set default schedule)</value>
        [DataMember(Name="reminders", EmitDefaultValue=false)]
        public string Reminders { get; set; }

        /// <summary>
        /// Return document links for signers in the response BODY.
        /// </summary>
        /// <value>Return document links for signers in the response BODY.</value>
        [DataMember(Name="return_signer_links", EmitDefaultValue=false)]
        public bool ReturnSignerLinks { get; set; }

        /// <summary>
        /// Notify signers in their order sequence. If false all are notified simulataneously.
        /// </summary>
        /// <value>Notify signers in their order sequence. If false all are notified simulataneously.</value>
        [DataMember(Name="signers_in_order", EmitDefaultValue=false)]
        public bool SignersInOrder { get; set; }

        /// <summary>
        /// Add custom placeholders to signer fields, using labels as keys in an object (as for pdftext). Relies on unique labelling.
        /// </summary>
        /// <value>Add custom placeholders to signer fields, using labels as keys in an object (as for pdftext). Relies on unique labelling.</value>
        [DataMember(Name="signertext", EmitDefaultValue=false)]
        public Dictionary<string, string> Signertext { get; set; }

        /// <summary>
        /// pdftext fails silently for invalid field value, set to true to return an error
        /// </summary>
        /// <value>pdftext fails silently for invalid field value, set to true to return an error</value>
        [DataMember(Name="strict_fields", EmitDefaultValue=false)]
        public bool StrictFields { get; set; }

        /// <summary>
        /// Gets or Sets Tag
        /// </summary>
        [DataMember(Name="tag", EmitDefaultValue=false)]
        public string Tag { get; set; }

        /// <summary>
        /// Assign document another user in the group. Defaults to API
        /// </summary>
        /// <value>Assign document another user in the group. Defaults to API</value>
        [DataMember(Name="user", EmitDefaultValue=false)]
        public string User { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class DocumentPost {\n");
            sb.Append("  Group: ").Append(Group).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Text: ").Append(Text).Append("\n");
            sb.Append("  Templatepdf: ").Append(Templatepdf).Append("\n");
            sb.Append("  Template: ").Append(Template).Append("\n");
            sb.Append("  Signers: ").Append(Signers).Append("\n");
            sb.Append("  SignatureType: ").Append(SignatureType).Append("\n");
            sb.Append("  AppendPdf: ").Append(AppendPdf).Append("\n");
            sb.Append("  AutoArchive: ").Append(AutoArchive).Append("\n");
            sb.Append("  DoEmail: ").Append(DoEmail).Append("\n");
            sb.Append("  CcEmails: ").Append(CcEmails).Append("\n");
            sb.Append("  ConvertSenderToSigner: ").Append(ConvertSenderToSigner).Append("\n");
            sb.Append("  Footer: ").Append(Footer).Append("\n");
            sb.Append("  FooterHeight: ").Append(FooterHeight).Append("\n");
            sb.Append("  Header: ").Append(Header).Append("\n");
            sb.Append("  HeaderHeight: ").Append(HeaderHeight).Append("\n");
            sb.Append("  PdfPassword: ").Append(PdfPassword).Append("\n");
            sb.Append("  PdfPasswordType: ").Append(PdfPasswordType).Append("\n");
            sb.Append("  Pdftext: ").Append(Pdftext).Append("\n");
            sb.Append("  Redirect: ").Append(Redirect).Append("\n");
            sb.Append("  Reminders: ").Append(Reminders).Append("\n");
            sb.Append("  ReturnSignerLinks: ").Append(ReturnSignerLinks).Append("\n");
            sb.Append("  SignersInOrder: ").Append(SignersInOrder).Append("\n");
            sb.Append("  Signertext: ").Append(Signertext).Append("\n");
            sb.Append("  StrictFields: ").Append(StrictFields).Append("\n");
            sb.Append("  Tag: ").Append(Tag).Append("\n");
            sb.Append("  User: ").Append(User).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as DocumentPost);
        }

        /// <summary>
        /// Returns true if DocumentPost instances are equal
        /// </summary>
        /// <param name="input">Instance of DocumentPost to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(DocumentPost input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Group == input.Group ||
                    (this.Group != null &&
                    this.Group.Equals(input.Group))
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.Text == input.Text ||
                    (this.Text != null &&
                    this.Text.Equals(input.Text))
                ) && 
                (
                    this.Templatepdf == input.Templatepdf ||
                    (this.Templatepdf != null &&
                    this.Templatepdf.Equals(input.Templatepdf))
                ) && 
                (
                    this.Template == input.Template ||
                    (this.Template != null &&
                    this.Template.Equals(input.Template))
                ) && 
                (
                    this.Signers == input.Signers ||
                    this.Signers != null &&
                    input.Signers != null &&
                    this.Signers.SequenceEqual(input.Signers)
                ) && 
                (
                    this.SignatureType == input.SignatureType ||
                    (this.SignatureType != null &&
                    this.SignatureType.Equals(input.SignatureType))
                ) && 
                (
                    this.AppendPdf == input.AppendPdf ||
                    (this.AppendPdf != null &&
                    this.AppendPdf.Equals(input.AppendPdf))
                ) && 
                (
                    this.AutoArchive == input.AutoArchive ||
                    (this.AutoArchive != null &&
                    this.AutoArchive.Equals(input.AutoArchive))
                ) && 
                (
                    this.DoEmail == input.DoEmail ||
                    (this.DoEmail != null &&
                    this.DoEmail.Equals(input.DoEmail))
                ) && 
                (
                    this.CcEmails == input.CcEmails ||
                    (this.CcEmails != null &&
                    this.CcEmails.Equals(input.CcEmails))
                ) && 
                (
                    this.ConvertSenderToSigner == input.ConvertSenderToSigner ||
                    (this.ConvertSenderToSigner != null &&
                    this.ConvertSenderToSigner.Equals(input.ConvertSenderToSigner))
                ) && 
                (
                    this.Footer == input.Footer ||
                    (this.Footer != null &&
                    this.Footer.Equals(input.Footer))
                ) && 
                (
                    this.FooterHeight == input.FooterHeight ||
                    (this.FooterHeight != null &&
                    this.FooterHeight.Equals(input.FooterHeight))
                ) && 
                (
                    this.Header == input.Header ||
                    (this.Header != null &&
                    this.Header.Equals(input.Header))
                ) && 
                (
                    this.HeaderHeight == input.HeaderHeight ||
                    (this.HeaderHeight != null &&
                    this.HeaderHeight.Equals(input.HeaderHeight))
                ) && 
                (
                    this.PdfPassword == input.PdfPassword ||
                    (this.PdfPassword != null &&
                    this.PdfPassword.Equals(input.PdfPassword))
                ) && 
                (
                    this.PdfPasswordType == input.PdfPasswordType ||
                    (this.PdfPasswordType != null &&
                    this.PdfPasswordType.Equals(input.PdfPasswordType))
                ) && 
                (
                    this.Pdftext == input.Pdftext ||
                    this.Pdftext != null &&
                    input.Pdftext != null &&
                    this.Pdftext.SequenceEqual(input.Pdftext)
                ) && 
                (
                    this.Redirect == input.Redirect ||
                    (this.Redirect != null &&
                    this.Redirect.Equals(input.Redirect))
                ) && 
                (
                    this.Reminders == input.Reminders ||
                    (this.Reminders != null &&
                    this.Reminders.Equals(input.Reminders))
                ) && 
                (
                    this.ReturnSignerLinks == input.ReturnSignerLinks ||
                    (this.ReturnSignerLinks != null &&
                    this.ReturnSignerLinks.Equals(input.ReturnSignerLinks))
                ) && 
                (
                    this.SignersInOrder == input.SignersInOrder ||
                    (this.SignersInOrder != null &&
                    this.SignersInOrder.Equals(input.SignersInOrder))
                ) && 
                (
                    this.Signertext == input.Signertext ||
                    this.Signertext != null &&
                    input.Signertext != null &&
                    this.Signertext.SequenceEqual(input.Signertext)
                ) && 
                (
                    this.StrictFields == input.StrictFields ||
                    (this.StrictFields != null &&
                    this.StrictFields.Equals(input.StrictFields))
                ) && 
                (
                    this.Tag == input.Tag ||
                    (this.Tag != null &&
                    this.Tag.Equals(input.Tag))
                ) && 
                (
                    this.User == input.User ||
                    (this.User != null &&
                    this.User.Equals(input.User))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Group != null)
                    hashCode = hashCode * 59 + this.Group.GetHashCode();
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.Text != null)
                    hashCode = hashCode * 59 + this.Text.GetHashCode();
                if (this.Templatepdf != null)
                    hashCode = hashCode * 59 + this.Templatepdf.GetHashCode();
                if (this.Template != null)
                    hashCode = hashCode * 59 + this.Template.GetHashCode();
                if (this.Signers != null)
                    hashCode = hashCode * 59 + this.Signers.GetHashCode();
                if (this.SignatureType != null)
                    hashCode = hashCode * 59 + this.SignatureType.GetHashCode();
                if (this.AppendPdf != null)
                    hashCode = hashCode * 59 + this.AppendPdf.GetHashCode();
                if (this.AutoArchive != null)
                    hashCode = hashCode * 59 + this.AutoArchive.GetHashCode();
                if (this.DoEmail != null)
                    hashCode = hashCode * 59 + this.DoEmail.GetHashCode();
                if (this.CcEmails != null)
                    hashCode = hashCode * 59 + this.CcEmails.GetHashCode();
                if (this.ConvertSenderToSigner != null)
                    hashCode = hashCode * 59 + this.ConvertSenderToSigner.GetHashCode();
                if (this.Footer != null)
                    hashCode = hashCode * 59 + this.Footer.GetHashCode();
                if (this.FooterHeight != null)
                    hashCode = hashCode * 59 + this.FooterHeight.GetHashCode();
                if (this.Header != null)
                    hashCode = hashCode * 59 + this.Header.GetHashCode();
                if (this.HeaderHeight != null)
                    hashCode = hashCode * 59 + this.HeaderHeight.GetHashCode();
                if (this.PdfPassword != null)
                    hashCode = hashCode * 59 + this.PdfPassword.GetHashCode();
                if (this.PdfPasswordType != null)
                    hashCode = hashCode * 59 + this.PdfPasswordType.GetHashCode();
                if (this.Pdftext != null)
                    hashCode = hashCode * 59 + this.Pdftext.GetHashCode();
                if (this.Redirect != null)
                    hashCode = hashCode * 59 + this.Redirect.GetHashCode();
                if (this.Reminders != null)
                    hashCode = hashCode * 59 + this.Reminders.GetHashCode();
                if (this.ReturnSignerLinks != null)
                    hashCode = hashCode * 59 + this.ReturnSignerLinks.GetHashCode();
                if (this.SignersInOrder != null)
                    hashCode = hashCode * 59 + this.SignersInOrder.GetHashCode();
                if (this.Signertext != null)
                    hashCode = hashCode * 59 + this.Signertext.GetHashCode();
                if (this.StrictFields != null)
                    hashCode = hashCode * 59 + this.StrictFields.GetHashCode();
                if (this.Tag != null)
                    hashCode = hashCode * 59 + this.Tag.GetHashCode();
                if (this.User != null)
                    hashCode = hashCode * 59 + this.User.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {


            // Group (string) pattern
            Regex regexGroup = new Regex(@"^\/api\/v1\/group\/[-\\w]{1,50}\/$", RegexOptions.CultureInvariant);
            if (false == regexGroup.Match(this.Group).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Group, must match a pattern of " + regexGroup, new [] { "Group" });
            }

            // Name (string) maxLength
            if(this.Name != null && this.Name.Length > 60)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Name, length must be less than 60.", new [] { "Name" });
            }

            // Name (string) minLength
            if(this.Name != null && this.Name.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Name, length must be greater than 1.", new [] { "Name" });
            }



            // Templatepdf (string) pattern
            Regex regexTemplatepdf = new Regex(@"^\/api\/v1\/templatepdf\/[-\\w]{1,60}\/$", RegexOptions.CultureInvariant);
            if (false == regexTemplatepdf.Match(this.Templatepdf).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Templatepdf, must match a pattern of " + regexTemplatepdf, new [] { "Templatepdf" });
            }



            // Template (string) pattern
            Regex regexTemplate = new Regex(@"^\/api\/v1\/template\/[-\\w]{1,60}\/$", RegexOptions.CultureInvariant);
            if (false == regexTemplate.Match(this.Template).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Template, must match a pattern of " + regexTemplate, new [] { "Template" });
            }



            // PdfPassword (string) pattern
            Regex regexPdfPassword = new Regex(@"^[-\\w ]{0,150}$", RegexOptions.CultureInvariant);
            if (false == regexPdfPassword.Match(this.PdfPassword).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for PdfPassword, must match a pattern of " + regexPdfPassword, new [] { "PdfPassword" });
            }

            // Redirect (string) maxLength
            if(this.Redirect != null && this.Redirect.Length > 250)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Redirect, length must be less than 250.", new [] { "Redirect" });
            }


            // Redirect (string) pattern
            Regex regexRedirect = new Regex(@"^https:\/\/", RegexOptions.CultureInvariant);
            if (false == regexRedirect.Match(this.Redirect).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Redirect, must match a pattern of " + regexRedirect, new [] { "Redirect" });
            }



            // Reminders (string) pattern
            Regex regexReminders = new Regex(@"^(default|)$", RegexOptions.CultureInvariant);
            if (false == regexReminders.Match(this.Reminders).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Reminders, must match a pattern of " + regexReminders, new [] { "Reminders" });
            }

            // Tag (string) maxLength
            if(this.Tag != null && this.Tag.Length > 250)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Tag, length must be less than 250.", new [] { "Tag" });
            }


            // Tag (string) pattern
            Regex regexTag = new Regex(@"^[-\\w\\[\\]\\:\\;\/\\.\\, _]{0,250}$", RegexOptions.CultureInvariant);
            if (false == regexTag.Match(this.Tag).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Tag, must match a pattern of " + regexTag, new [] { "Tag" });
            }

            yield break;
        }
    }

}
